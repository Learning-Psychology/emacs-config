;; -*- mode: emacs-lisp; coding: emacs-mule; -*-
;; --------------------------------------------------------------------------
;; Desktop File for Emacs
;; --------------------------------------------------------------------------
;; Created Fri Dec 12 17:37:50 2014
;; Desktop file format version 206
;; Emacs version 24.3.1

;; Global section:
(setq comint-input-ring nil)
(setq compile-history nil)
(setq desktop-missing-file-warning nil)
(setq dired-regexp-history nil)
(setq extended-command-history '("customize-group" "byte-compile-file" "oicq" "magit-log" "magit-pull" "ibus-mode" "kill-some-buffers" "slime"))
(setq face-name-history nil)
(setq file-name-history '("/home/akitsuki/.emacs.d/lisp/1.c" "/home/akitsuki/.emacs.d/lisp/template.el" "/home/akitsuki/.emacs.d/init.el" "/home/akitsuki/.emacs.d/templates/post.md" "/home/akitsuki/github-repos/github-blog/_posts/postcache.md" "/home/akitsuki/.bashrc" "/home/akitsuki/.emacs.d/init.el" "/home/akitsuki/github-repos/github-blog/about.md" "/home/akitsuki/github-repos/github-blog/_config.yml" "/home/akitsuki/.emacs.d/init.el" "~/.emacs.d/lisp/ibus-el-0.3.2/ibus.el" "~/.emacs.d/lisp/ibus-el-0.3.2/README" "/home/akitsuki/.emacs.d/init.el" "~/Documents/examples/_posts/2014-01-01-example-content.md" "/home/akitsuki/find.help" "/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/Relations-Text.tpd" "/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/Findkeywords.sh" "~/workspaces/lisp-practise/c9/simple-test.lisp" "/etc/hosts" "/home/akitsuki/workspaces/lisp-practise/c9/simple-test.lisp" "~/kuali/current-work-stream/AcademicCalendarView.xml" "~/.bash_history" "~/kuali/current-work-stream/ResultValueInfoAdminLookupView.xml" "~/.emacs.d/lisp/init-slime.el" "~/Documents/Kuali‘Ïî‘Ä¿‘¼Æ‘»®‘½ø‘¶È‘±í.xls" "~/.ido.last" "~/.emacs.d/site-lisp/README" "~/kuali/current-work-stream/CourseMaintenanceView.xml" "~/Documents/Kuali‘Ïî‘Ä¿‘¼Æ‘»®‘½ø‘¶È‘±í.xls" "~/kuali/current-work-stream/CourseMaintenanceView.xml" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history" "~/workspaces/ideaProjects/enrollment/aggregate/Notice.txt" "~/opt/tomcat7-8082/bin/catalina.sh" "~/opt/opengrok-0.12.1/bin/OpenGrok" "~/.local/share/Trash/files/aggregate/Relations-Find a Course Proposal.tpd" "~/workspaces/lisp-practise/c9/simple-test.lisp" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/src/main/resources/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/target/classes/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/kuali/current-work-stream/AcademicCalendarView.xml" "~/kuali/current-work-stream/AcademicTermLookupView.xml" "~/kuali/current-work-stream/EnrollmentHomeView.xml" "~/kuali/current-work-stream/CurriculumHomeView.xml" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history" "~/workspaces/ideaProjects/enrollment/aggregate/Notice.txt" "~/opt/tomcat7-8082/bin/catalina.sh" "~/opt/opengrok-0.12.1/bin/OpenGrok" "~/.local/share/Trash/files/aggregate/Relations-Find a Course Proposal.tpd" "~/workspaces/lisp-practise/c9/simple-test.lisp" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/src/main/resources/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/target/classes/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/kuali/current-work-stream/AcademicCalendarView.xml" "~/kuali/current-work-stream/AcademicTermLookupView.xml" "~/kuali/current-work-stream/EnrollmentHomeView.xml" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history" "~/workspaces/ideaProjects/enrollment/aggregate/Notice.txt" "~/opt/tomcat7-8082/bin/catalina.sh" "~/opt/opengrok-0.12.1/bin/OpenGrok" "~/.local/share/Trash/files/aggregate/Relations-Find a Course Proposal.tpd" "~/workspaces/lisp-practise/c9/simple-test.lisp" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/src/main/resources/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/target/classes/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/kuali/current-work-stream/AcademicCalendarView.xml" "~/kuali/current-work-stream/AcademicTermLookupView.xml" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history" "~/workspaces/ideaProjects/enrollment/aggregate/Notice.txt" "~/opt/tomcat7-8082/bin/catalina.sh" "~/opt/opengrok-0.12.1/bin/OpenGrok" "~/.local/share/Trash/files/aggregate/Relations-Find a Course Proposal.tpd" "~/workspaces/lisp-practise/c9/simple-test.lisp" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/src/main/resources/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/target/classes/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/kuali/current-work-stream/AcademicCalendarView.xml" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history" "~/workspaces/ideaProjects/enrollment/aggregate/Notice.txt" "~/opt/tomcat7-8082/bin/catalina.sh" "~/opt/opengrok-0.12.1/bin/OpenGrok" "~/.local/share/Trash/files/aggregate/Relations-Find a Course Proposal.tpd" "~/workspaces/lisp-practise/c9/simple-test.lisp" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/src/main/resources/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment/aggregate/ks-lum/ks-cm-krad/target/classes/org/kuali/student/cm/main/CurriculumHomeView.xml" "~/workspaces/ideaProjects/enrollment2/ks-final-milestone (copy)/build.log" "~/.emacs.d/site-lisp/README" "~/backup/.emacs" "~/.emacs.d/lisp/init-slime.el" "~/.bash_history"))
(setq grep-find-history nil)
(setq grep-history nil)
(setq ido-buffer-history '("template.el" "*unsent mail*" "template.el" "*Customize Group: Template*" "template.el" "init.el" "*scratch*" "init.el" "*ansi-term*<2>" "post.md" "postcache.md" ".bashrc" "init.el" "*scratch*" "about.md" "_config.yml" "init.el" "README" "ibus.el" "init.el" "*scratch*" "find.help" "2014-01-01-example-content.md" "*scratch*" "*Messages*" "*slime-events*" "*Compile-Log*" "*scratch*" "*inferior-lisp*" "*slime-repl clisp*" "*inferior-lisp*" "*slime-repl clisp*" "*inferior-lisp*" "*slime-events*" "*Messages*" "*scratch*" "*ansi-term*" "Relations-Text.tpd" "Findkeywords.sh" "*ansi-term*" "simple-test.lisp" "*scratch*" "*Messages*" "simple-test.lisp" "*Compile-Log*" "hosts" "*ansi-term*" " *undo-tree*" "AcademicCalendarView.xml" ".bash_history" "ResultValueInfoAdminLookupView.xml" "init-slime.el" "Kuali‘Ïî‘Ä¿‘¼Æ‘»®‘½ø‘¶È‘±í.xls" nil ".ido.last" " *Echo Area 0*" "README" "CourseMaintenanceView.xml" "Kuali‘Ïî‘Ä¿‘¼Æ‘»®‘½ø‘¶È‘±í.xls" "CourseMaintenanceView.xml" "*Messages*" "*scratch*" "*Messages*" "*Compile-Log*" "*scratch*" "README" ".emacs" "init-slime.el" ".bash_history" "Notice.txt" "catalina.sh" "OpenGrok" "Relations-Find a Course Proposal.tpd" "simple-test.lisp" "CurriculumHomeView.xml" "CurriculumHomeView.xml —£À classes" "AcademicCalendarView.xml" "AcademicTermLookupView.xml" "EnrollmentHomeView.xml" "CurriculumHomeView.xml —£À current-work-stream" "CourseMaintenanceView.xml" " *undo-tree*" "krad-base-servlet.xml" "do-primes.lisp" "EnrollmentHomeView.xml" " *undo-tree*" "simple-test.lisp" "*inferior-lisp*<5>" "*slime-repl clisp<2>*" "*ansi-term*<2>" "macro-utilities.asd" "macro-utilities.lisp" "*slime-macroexpansion*" "*slime-repl clisp*" "*ansi-term*<2>" "do-primes.lisp" "*slime-repl clisp*" "do-primes.lisp" "*ansi-term*<2>" "*slime-events*"))
(setq ido-last-directory-list '(("/home/akitsuki/.emacs.d/" . "lisp/") ("/home/akitsuki/github-repos/github-blog/" . "_posts/") ("/home/akitsuki/github-repos/github-blog/_posts/" . "postcache.md/") ("/home/akitsuki/workspaces/lisp-practise/answers/" . "Chapter08/") ("/home/akitsuki/workspaces/" . "lisp-practise/") ("/home/akitsuki/workspaces/lisp-practise/" . "c9/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/student/common/ui/server/" . "start/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/student/common/ui/" . "server/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/student/common/" . "ui/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/student/" . "common/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/" . "student/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/" . "kuali/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/" . "org/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/" . "java/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/" . "main/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/" . "src/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/" . "ks-common-ui/") ("/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/" . "ks-common/") ("/home/akitsuki/" . ".emacs.d/") ("/" . "etc/")))
(setq ido-work-directory-list '("/home/akitsuki/.emacs.d/lisp/" "/home/akitsuki/.emacs.d/" "/home/akitsuki/.emacs.d/templates/" "/home/akitsuki/github-repos/github-blog/_posts/" "/home/akitsuki/" "/home/akitsuki/github-repos/github-blog/" "/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/" "/etc/" "/home/akitsuki/workspaces/lisp-practise/c9/" "/home/akitsuki/workspaces/lisp-practise/answers/Chapter08/" "/home/akitsuki/workspaces/lisp-practise/c8/" "/home/akitsuki/workspaces/ideaProjects/enrollment/aggregate/ks-core/ks-common/ks-common-ui/src/main/java/org/kuali/student/common/ui/server/start/" "/home/akitsuki/Documents/akitsukikiritsugu.github.io/_posts/"))
(setq ido-work-file-list '("1.c" "template.el" "init.el" "post.md" "postcache.md" ".bashrc" "about.md" "_config.yml" "find.help" "Relations-Text.tpd"))
(setq magit-read-rev-history nil)
(setq minibuffer-history '("template" "load-path" "/bin/bash" "misakamikoto" "240799357" "/bin/bash"))
(setq org-clock-history nil)
(setq org-refile-history nil)
(setq org-tags-history nil)
(setq query-replace-history '(".emacs.d/templates" ".templates" ".templates" ".emacs.d/templates" ".template"))
(setq read-expression-history '("q"))
(setq regexp-history nil)
(setq regexp-search-ring nil)
(setq register-alist '((48 . "   (\"T\" . \"DATE\")\n    (\"V\" . \"VC_DATE\")\n    (\"Y\" . \"YEAR\")\n    (\"I\" . \"ISO_DATE\")\n    (\"C\" . \"COMMENT\")\n    (\"A\" . \"AUTHOR\")\n    (\"U\" . \"USER_NAME\")\n    (\"L\" . \"LOGIN_NAME\")\n    (\"H\" . \"HOST_ADDR\")\n    (\"Z\" . \"ZERO_FORM\"))\n  \"Alist to support the old one-letter predefined expansion forms.\nUsed for `template-expansion-alist' and\n`template-default-expansion-alist'.\")\n\n(defcustom template-definition-start\n  \">>>TEMPLATE-DEFINITION-SECTION<<<\"\n  \"Header for the per-template definition section.\nThe region following the the first match of this regexp defines the\nper-template definition section.  The region will be deleted before the\nactual expansion, see `template-new-file'.  If you use the \\\"Local\nVariables:\\\" section, define it before this region.\n\nThe definition section defines expansion forms for strings KEYs matched\nby `template-expansion-regexp' which might shadow those in\n`template-expansion-alist' and `template-default-expansion-alist':\n\n  (\\\"KEY\\\"): zero form, same as (>>>ZERO_FORM<<<) in default value of\n`template-default-expansion-alist', useful for inserting text matched by\n`template-expansion-regexp' literally.\n\n  (\\\"KEY\\\". CHAR): CHAR is the register where the current buffer\nposition is stored, see `template-register-regexp'.\n\n  (\\\"KEY\\\" \\\"PROMPT\\\" \\\"PREFIX\\\" \\\"SUFFIX\\\" \\\"DEFAULT\\\" AGAIN-P) where\nthe last four arguments are optional: ask user with PROMPT for a STRING.\nIf STRING is not \\\"\\\", insert PREFIX STRING SUFFIX, otherwise DEFAULT.\nFor AGAIN-P, see `template-read'.  To define, use\n\\\\[template-define-prompt].\n\n  (\\\"KEY\\\" \\\"PROMPT\\\" (\\\"ANSWER\\\" \\. \\\"TEXT\\\")...): ask user with PROMPT\nfor an input with completion over all ANSWERs and insert corresponding\nTEXT.  Expansion forms in TEXT will be expanded.\n\n  (\\\"KEY\\\" \\\"PROMPT\\\" (t \\. \\\"TEXT-y\\\")  (nil \\. \\\"TEXT-n\\\")): ask user\nwith PROMPT a \\\"y or n\\\" question with `y-or-n-p' and insert TEXT-y or\nTEXT-n, correspondingly.  Expansion forms in TEXT-X will be expanded.\nThe y-case and the n-case are optional and can be exchanged.\n\n  (\\\"KEY\\\" \\. SYMBOL): insert value of SYMBOL; if value is no string at\nthe time of the replacement, use `template-string-default' as format\nstring for SYMBOL.\n\n  (\\\"KEY\\\" COMMAND \\. PREFIX): COMMAND is a symbol or a vector and is\ncalled with `command-execute' after setting `prefix-arg' to PREFIX, not\nevaluated.  If COMMANDs symbol property `template-secure-command' is\nnil, the form is insecure.  If that symbol property is a function, it is\ncalled with PREFIX to check whether COMMAND could be called directly\nwith PREFIX as remaining arguments.\n\n  (\\\"KEY\\\" SEXPR...): evaluate SEXPR during the expansion, see\n`template-expansion-alist' for examples.  This form is insecure.\n\nThere are other per-template definitions:\n\n  \\\"MESSAGE\\\": additional line displayed at point until first user event\nor after `template-message-timeout' seconds.  The lines are displayed\nwith face in `template-message-face'.  With active form selector\n:before, define a message which is displayed in\n`template-message-buffer' before the exansion has started.  With active\nform selector :after, define a message which is displayed in\n`template-message-buffer' after the exansion has taken place.  To\ndefine interactively, use \\\\[template-define-message].\n\n  (CHAR \\. \\\"CONTENTS\\\"): Set register CHAR to have contents CONTENTS.\nCONTENTS can then be inserted into a buffer with \\\\[insert-register] CHAR.\n\n  (CHAR \\\"CONTENTS\\\" COMMENT) where COMMENT is optional: Set register\nCHAR to have contents CONTENTS.  CONTENTS can then be inserted into a\nbuffer with \\\\[insert-register] CHAR.  Also display an additional line\nat point to show the contents with COMMENT.  To define, use\n\\\\[template-define-register].\n\nThe following forms depend on the active form selector which is the last\nof the following expansion forms:\n - :before: \\\"MESSAGE\\\" will be displayed before the expansion\n - :after: \\\"MESSAGE\\\" will be displayed after the expansion\n - :eval-before: execute COMMAND and SEXPR before expansion\n - :eval-after: execute COMMAND and SEXPR after expansion\n - nil, deprecated: with the first form, the active form selector is\n   :eval-before, with the second, it is :eval-after.\n\n  (VARIABLE . VALUE): set SYMBOL's local value to VALUE, not evaluated.\nThis form is only secure if VARIABLE has a symbol property\n`template-secure-value' which returns non-nil when applied to VALUE, not\nevaluated.  This form is useful for variables which determine the\nexpansion, like `template-time-format' and `template-date-format'.  For\nlocal variables in your new file, use the normal way via the \\\"Local\nVariables:\\\" section.  The active form selector must not be :eval-before\nor :eval-after.\n\n  COMMAND: COMMAND is a symbol or a vector and is called with\n`command-execute' before the expansion with form selector :eval-before,\nand after the expansion with form selector :eval-after.  If COMMANDs\nsymbol property `template-secure-command' is nil, the form is insecure.\nYou should use the safe command `normal-mode' in the pre-expansion forms\nif the expansion forms depend on the correct major mode.\n\n  SEXPR: evaluate SEXPR before the expansion with form selector\n:eval-before, and after the expansion with form selector :eval-after.\nThis form is insecure.\n\nIf any insecure forms have been used, the user of the template will be\nasked whether to use the template, see `template-confirm-insecure'.\"\n  :group 'template-expansion\n  :type 'string)\n\n\n\f\n;;;;##########################################################################\n;;;;  Commenting\n;;;;##########################################################################\n\n\n(defunx template-point-at-bol (&optional count)\n  :emacs-only line-beginning-position\n  :xemacs-only point-at-bol)\n\n(defunx template-point-at-eol (&optional count)\n  :emacs-only line-end-position\n  :xemacs-only point-at-eol)\n\n(defunx template-char-or-char-int-p (object)\n  :emacs-only integerp\n  :xemacs-only char-or-char-int-p)\n\n(defunx template-char-or-int-to-char (object)\n  :emacs-only identity\n  \"Convert character or integer OBJECT into the equivalent character.\"\n  (if (characterp object) object (int-to-char object)))\n\n\n;;;===========================================================================\n;;;  Main functions\n;;;===========================================================================\n\n;;;###autoload\n(defun template-single-comment (&optional arg)\n  \"Decorate the comment in the current line with dashes and alike.\nThe line must be a comment-only line or must contain a comment ending by\neol.  That is, jump to the end of the current line and insert the dashes\nand the final comment end-string up-to the fill position.  Prefix\nargument ARG and `template-comment-specification' determines the comment\nstyle to use.  The length of the resulting line is determined by\n`template-max-column' and `template-max-column-with-end'.\"\n  (interactive \"*P\")\n  (let* ((orig (point-marker))\n	 (syntax0 (and comment-start comment-start-skip\n		       (condition-case nil\n			   (template-comment-syntax orig 'boc)\n			 (error nil))))\n	 (syntax (cond ((cdr syntax0)\n			(template-comment-syntax orig))\n		       (syntax0\n			(condition-case nil\n			    (template-comment-syntax (point-marker))\n			  (error syntax0)))\n		       (t\n			(back-to-indentation)\n			nil)))\n	 (sep (template-comment-separator-regexp syntax))\n	 (end (template-point-at-eol))\n	 old)\n    (save-excursion\n      (cond ((re-search-forward sep end t)\n	     ;; with sep in current line\n	     (setq old (buffer-substring (match-beginning 1) (match-end 1)))\n	     (delete-region (match-beginning 0) (match-end 0)))\n	    ((cdr syntax)		; with start-end comment\n	     (if (looking-at (concat \"[ \\t]*\\\\(.+\\\\)?\"\n				     (regexp-quote (cadr syntax))\n				     \"[ \\t]*\\\\(.+\\\\)?$\"))\n		 (if (or (match-beginning 1) (match-beginning 2))\n		     (error \"This line contains non-separator chars and %S\"\n			    (cadr syntax))\n		   ;; Delete comment-end.  Don't delete its first char if it is\n		   ;; the same as the second of comment-start.\n		   (delete-region (if (and (= (length (car syntax)) 2)\n					   (= (length (cadr syntax)) 2)\n					   (eq (aref (car syntax) 1)\n					       (aref (cadr syntax) 0)))\n				      (1+ (match-beginning 0))\n				    (match-beginning 0))\n				  (match-end 0))))\n	     (goto-char (cddr syntax))\n	     (if (re-search-forward sep end t)\n		 ;; sep in line between comment-start and point-at-eol\n		 (setq old (buffer-substring (match-beginning 1)\n					     (match-end 1)))))))\n    (template-insert-separator\n     (car (template-comment-specification arg old syntax))\n     nil syntax)))\n(put 'template-single-comment 'template-secure-command t)\n\n;;;###autoload\n(defun template-block-comment (&optional arg)\n  \"Decorate the current block of comment-only lines with dashes and alike.\nThat is, surround the the contiguous comment-only lines around point\nwith extra lines containing dashes and alike and to put the correct\nnumber of newlines around the block.\n\nBarf if the comment syntax at point has a non-empty `comment-end' or if\npoint is not in a comment-only line.\n\nA block comment consists of all neighboring lines which start with\nspaces and `comment-start'.  If `comment-start' is a string of length 1,\nthe number of repetitions of `comment-start' must be the same or larger\nthan in the line where the command is invoked from, too.\n\nPrefix argument ARG and `template-comment-specification' determines the\ncomment style to use.  The length of the separator line is determined by\n`template-max-column'.\n\nThis command can also be used with point in an empty line after a block\ncomment.  A second invocation of this command directly after a\nsuccessful invocation deletes the remaining empty lines from the current\nline on.\"\n  (interactive \"*P\")\n  (let* ((orig (point-marker))\n	 (syntax (progn\n		   (end-of-line)\n		   (skip-chars-backward \" \\t\\n\\f\")\n		   (template-comment-syntax orig))))\n    (when (cdr syntax)\n      (goto-char orig)\n      (error \"Command only works with comments terminated by end-of-line\"))\n    \n    (if (and (eq last-command 'template-block-comment-success)\n	     (looking-at \"[ \\t]*$\"))\n	(template-insert-newline \"\" nil (1- (template-point-at-bol)))\n      (let* ((prefix (concat \"[ \\t]*\" (regexp-quote (car syntax))))\n	     (sepline (concat prefix \"[ \\t]*\"\n			      (template-comment-separator-regexp syntax)))\n	     old block-beg block-end def)\n	;; go to the first line with same comment prefix ---------------------\n	(beginning-of-line)\n	(while (and (not (bobp)) (looking-at prefix))\n	  (beginning-of-line 0))\n	(or (looking-at prefix) (beginning-of-line 2))\n	(while (looking-at sepline)\n	  (setq old (buffer-substring (1- (match-end 0)) (match-end 0)))\n	  (kill-line 1))\n	(setq block-beg (point-marker))\n	;; go to the last line with same comment prefix ----------------------\n	(while (looking-at prefix)\n	  (template-indent-according-to-mode)\n	  (beginning-of-line 2))\n	(if (eobp) (newline))\n	(setq block-end (copy-marker (point) t))\n	(while (progn (forward-line -1) (looking-at sepline))\n	  (setq old (buffer-substring (1- (match-end 0)) (match-end 0)))\n	  (kill-line 1))\n	;; insert separator lines --------------------------------------------\n	(goto-char block-beg)\n	(set-marker block-beg nil)\n	(back-to-indentation)\n	(setq def (template-comment-specification arg old syntax))\n	(beginning-of-line)\n	(template-insert-newline (cadr def))\n	(template-insert-separator (car def) (car syntax) syntax)\n	(goto-char block-end)\n	(set-marker block-end nil)\n	(template-insert-separator (car def) (car syntax) syntax)\n	(template-insert-newline (caddr def)\n				 (and (cadddr def)\n				      (save-excursion\n					(forward-line (cadddr def))\n					(point))))\n	(setq this-command 'template-block-comment-success)))\n    (template-indent-according-to-mode)\n    (back-to-indentation)))\n(put 'template-block-comment 'template-secure-command t)\n\n\n;;;===========================================================================\n;;;  Check comment start, return specification\n;;;===========================================================================\n\n(defun template-indent-according-to-mode ()\n  \"Indent line according to `template-comment-indent'.\"\n  (if (if template-comment-indent\n	  (not (memq major-mode template-indent-mode-disable-list))\n	(memq major-mode template-indent-mode-enable-list))\n      (indent-according-to-mode)))\n\n(defun template-default-comment ()\n  \"Return default comment according to current position.\"\n  (if comment-start\n      (substring comment-start 0 (string-match \"[ \\t]\\\\'\" comment-start))\n    (if (eolp) \"#\"\n      (let ((default (buffer-substring (point) (1+ (point)))))\n	(if (string-match \"[A-Za-z]\" default) \"#\" default)))))\n\n(defun template-comment-at-point ()\n  \"Return the comment syntax at the current position.\nReturn nil, if no commenting command can be used, i.e., if point is not\nin a comment-only line.  Return `none' if the `major-mode' doesn't\ndefine a comment syntax.  Return `delimited' if point is between\n`comment-start' and a non-empty `comment-end'.  Return `single' if point\nis in a comment line where the comment syntax has a empty `comment-end',\nreturn `block' if point is in an empty line after such a comment line.\"\n  (if (and comment-start comment-start-skip)\n      (save-excursion\n	(let ((orig (point)))\n	  (condition-case nil\n	      (progn\n		(end-of-line)\n		(skip-chars-backward \" \\t\\n\\f\")\n		(if (cdr (template-comment-syntax orig t)) 'delimited\n		  (if (< (template-point-at-eol) orig) 'block 'single)))\n	    (error\n	     (condition-case nil\n		 (progn\n		   (goto-char orig)\n		   (beginning-of-line)\n		   (when (re-search-forward comment-start-skip\n					    (template-point-at-eol) t)\n		     (goto-char (or (match-end 1) (match-beginning 0)))\n		     (unless (or (cdr (template-comment-syntax orig 'boc))\n				 (< (template-point-at-eol) orig))\n		       'cont)))\n	       (error nil))))))\n    'none))\n\n(defun template-comment-syntax (orig &optional no-indent)\n  \"Return the comment syntax at ORIG.  Signal error if not in comment.\nReturn (COMMENT-START) if the comment syntax has an empty `comment-end'.\nReturn (COMMENT-START COMMENT-END . START-POS) if the comment syntax has\na non-empty `comment-end' where START-POS is the position of the first\ncharacter inside the comment.  Move point to first character after the\ncomment start or the first non-whitespace character on this line.\n\nORIG should be the same as `point' or in a empty line after `point'.\n\nIf optional argument NO-INDENT is nil, indents the current line\naccording to `template-comment-indent' and `indent-according-to-mode'.\nIf NO-INDENT is `boc', move point to the beginning of the comment.\n\nCOMMENT-START is stripped off its final spaces, COMMENT-END off its\ninitial spaces.\"\n  (unless (and comment-start comment-start-skip)\n    (error \"No comment syntax has been defined for %s\" major-mode))\n  (if (eq no-indent 'boc)\n      (progn\n	(beginning-of-line)\n	(if (re-search-forward comment-start-skip (template-point-at-eol) t)\n	    (goto-char (or (match-end 1) (match-beginning 0)))))\n    (or no-indent (template-indent-according-to-mode))\n    (back-to-indentation))\n  (let* ((string (template-default-comment)))\n    (if (string= comment-end \"\")\n	(if (looking-at (concat (regexp-quote string)\n				(and (= (length string) 1)\n				     (not (eq no-indent 'boc))\n				     \"+\")))\n	    (progn\n	      (goto-char (match-end 0))\n	      (list (buffer-substring (match-beginning 0) (point))))\n	  (let ((alist template-alt-comment-syntax-alist)\n		elem c-start c-end)\n	    (while alist\n	      (setq elem (pop alist))\n	      (and (template-match-modes-or-regexp (car elem))\n		   (string-match comment-start-skip (cadr elem))\n		   (setq c-start (cadr elem)\n			 c-end   (caddr elem)\n			 alist   nil)))\n	    (template-comment-syntax-0 orig c-start c-end string)))\n      (template-comment-syntax-0 orig comment-start comment-end))))\n\n(defun template-comment-syntax-0 (orig c-start c-end &optional single)\n  ;; checkdoc-params: (orig c-start c-end single)\n  \"Internal function for `template-comment-syntax'.\"\n  (unless (and (stringp c-start) (stringp c-end) (not (string= c-end \"\")))\n    (goto-char orig)\n    (error \"Line does not start with %S\"\n	   (or single (template-default-comment))))\n  (setq c-start (substring c-start 0 (string-match \"[ \\t]\\\\'\" c-start))\n	c-end   (if (string-match \"\\\\`[ \\t]+\" c-end)\n		    (substring c-end (match-end 0))\n		  c-end))\n  (cond ((looking-at (regexp-quote c-start))\n	 (goto-char (match-end 0))\n	 (cons c-start (cons c-end (point))))\n	((save-excursion\n	   (when (re-search-backward (concat \"^[ \\t]*\" (regexp-quote c-start))\n				     nil t)\n	     (goto-char (match-end 0))\n	     (let ((match (point)))\n	       (unless (when (search-forward c-end orig t)\n			 (skip-chars-forward \" \\t\")\n			 (< (point) orig))\n		 (cons c-start (cons c-end match)))))))\n	(t\n	 (goto-char orig)\n	 (if single\n	     (error \"Not inside a comment (%S or %S-%S) starting in new line\"\n		    single c-start c-end)\n	   (error \"Not inside a comment (%S-%S) starting in new line\"\n		  c-start c-end)))))\n\n\n;;;===========================================================================\n;;;  Comment specification\n;;;===========================================================================\n\n;; A simple `mapconcat' is likely to slow down Emacs' regexp search algorithm\n;; considerably (backtracking => near-infloop).\n(defun template-comment-separator-regexp (syntax)\n  \"Return regexp matching separator comment lines.\nThe regexp also matches if the lines ends with parts of COMMENT-END in\nargument SYNTAX, see `template-comment-syntax'.\"\n  (let ((estring (cadr syntax))\n	(alist template-comment-specification-alist)\n	(chars nil)\n	str i c)\n    (while alist\n      (setq str (car (pop alist)))\n      (when str\n	(setq i (length str))\n	(while (>= (decf i) 0)\n	  ;; (pushnew (aref str i) chars), but requires cl at runtime:\n	  (or (memq (setq c (aref str i)) chars) (push c chars)))))\n    (concat \"\\\\(\"\n	    (mapconcat (lambda (c) (regexp-quote (char-to-string c)))\n		       (or chars \"#\")\n		       \"\\\\|\")\n	    (if estring\n		(concat \"\\\\)+[ \\t]*\"\n			(mapconcat (lambda (c)\n				     (regexp-quote (char-to-string c)))\n				   estring\n				   \"?\")\n			\"?[ \\t]*$\")\n	      \"\\\\)+[ \\t]*$\"))))\n\n(defun template-comment-specification (arg old syntax)\n  \"Return the comment specification to use.\nSee `template-comment-specification-alist' for details.  ARG is the\nprefix argument, OLD the SEPARATOR of the old comment style and SYNTAX\nis the comment syntax returned by `template-comment-syntax'.\"\n  (and arg (setq arg (prefix-numeric-value arg)))\n  ;; assumes point-at-indentation\n  (or (and arg (> arg 0)\n	   (if (< (length template-comment-specification-alist) arg)\n	       (car (last template-comment-specification-alist))\n	     (nth (1- arg) template-comment-specification-alist)))\n      (and (null arg) old\n	   (assoc old template-comment-specification-alist))\n      (and (functionp template-comment-specification-special)\n	   (funcall template-comment-specification-special))\n      (and (functionp (get major-mode 'template-comment-specification-special))\n	   (funcall (get major-mode 'template-comment-specification-special)))\n      (and syntax\n	   (template-comment-specification\n	    (if (or (cdr syntax) (> (length comment-start) 1))\n		(save-excursion\n		  (if (cddr syntax) (goto-char (cddr syntax)))\n		  (beginning-of-line)\n		  (if (looking-at \"[ \\t]\") 2 3))\n	      (length (car syntax)))\n	    nil nil))\n      '(\"-\" \"\" \"\" 0)))\n\n\n;;;===========================================================================\n;;;  Inserting\n;;;===========================================================================\n\n(defun template-insert-newline (string &optional limit start-limit)\n  \"Deletes blank lines around point and insert STRING.\nAfter optional LIMIT and before optional START-LIMIT, no character will\nbe deleted.\"\n  (let ((start (save-excursion\n		 (skip-chars-backward \" \\t\\n\\f\" start-limit)\n		 (or (bobp) (forward-line 1))\n		 (point)))\n	(end (save-excursion\n	       (skip-chars-forward \" \\t\\n\\f\" limit)\n	       (beginning-of-line)\n	       (point))))\n    (if (> end start) (delete-region start end)))\n  (or (bobp) (insert string)))\n\n(defun template-insert-separator (separator &optional cstring syntax)\n  \"Insert separator line at point.\nIf CSTRING is not nil, insert in special line which starts with CSTRING.\nInsert SEPARATOR repeatedly.  End the line with COMMENT-END as specified\nin `template-comment-syntax'.\"\n  (when separator\n    (when cstring\n      (open-line 1)\n      (insert cstring)\n      (template-indent-according-to-mode))\n    (end-of-line)\n    (let* ((estring (cadr syntax))\n	   (max-column (if estring\n			   template-max-column-with-end\n			 template-max-column))\n	   (max (- (if (> max-column 0) max-column (+ fill-column max-column))\n		   (length separator)\n		   (length estring))))\n      (while (<= (current-column) max) (insert separator))\n      (if (>= (length separator) (- (current-column) max))\n	  (insert (substring separator 0 (- max (current-column)))))\n      (if estring (insert estring))\n      (if cstring (forward-line 1)))))\n\n\n;;;===========================================================================\n;;;  Adaptations: cc-mode\n;;;===========================================================================\n\n;; There isn't really anything I can do against the filling of \"/**\" in C, C++\n;; and Antlr mode (it is correct in Java), it should be done in the cc-mode\n;; package.  Similar for filling \"*/\" with the previous line...\n\n(defun template-c-fill-paragraph (&optional arg)\n  ;; checkdoc-params: (arg)\n  \"Like \\\\[c-fill-paragraph] but handles comment separator lines.\"\n  (let* ((regexp (concat \"\\\\|[ \\t]*\\\\(/[*/]\\\\|\\\\*\\\\)[ \\t]*\"\n			 (template-comment-separator-regexp '(\"/*\" \"*/\"))))\n	 (paragraph-start (concat paragraph-start regexp)) ;#dynamic\n	 (paragraph-separate (concat paragraph-separate regexp)))\n    (c-fill-paragraph arg)))\n\n(defun template-c-init-fill-function ()\n  \"Set `fill-paragraph-function' to use `template-c-fill-paragraph'.\"\n  (when (boundp 'fill-paragraph-function)\n    (make-local-variable 'fill-paragraph-function)\n    (setq fill-paragraph-function 'template-c-fill-paragraph)))\n\n\n\f\n;;;;##########################################################################\n;;;;  Updating (File Name in Header)\n;;;;##########################################################################\n\n\n;;;===========================================================================\n;;;  General updating\n;;;===========================================================================\n\n(defun template-update-buffer-region (limit regexp group)\n  \"Return region = (BEG . END) in buffer to be updated.\nIf LIMIT is positive, check first LIMIT characters in buffer, otherwise\ncheck last -LIMIT characters in buffer for a text to be matched by\nREGEXP.  Return region according to GROUP's regexp group in REGEXP.\"\n  (let ((case-fold-search nil))\n    (goto-char (if limit\n		   (if (natnump limit) (point-min) (+ (point-max) limit))\n		 (point-min)))\n    (when (re-search-forward regexp\n			     (if (natnump limit)\n				 (+ (point-min) limit)\n			       (point-max))\n			     t)\n      (cons (match-beginning group) (match-end group)))))\n\n(defun template-match-modes-or-regexp (modes-or-regexp)\n  \"Return non-nil, if the current buffer passes MODES-OR-REGEXP.\nIf MODES-OR-REGEXP is a list, it must include the current `major-mode',\nif it is a regexp, it must match the `buffer-file-name' without version,\notherwise it must be non-nil.\"\n  (if (stringp modes-or-regexp)\n      (and buffer-file-name\n	   (string-match modes-or-regexp\n			 (file-name-sans-versions buffer-file-name)))\n    (or (nlistp modes-or-regexp) (memq major-mode modes-or-regexp))))\n\n(defun template-update-buffer (&optional arg)\n  \"Update buffer according to `template-update-buffer-alist'.\nDo not do anything if `template-auto-update-disable-regexp' matches the\nfile name or if `template-auto-update' is nil.  When optional ARG is\nnon-nil, i.e., if called interactively *without* prefix arg, always\nupdate.\"\n  (interactive (list (null current-prefix-arg)))\n  (when (or arg\n	    (and template-auto-update buffer-file-name\n		 (null (and template-auto-update-disable-regexp\n			    (string-match template-auto-update-disable-regexp\n					  buffer-file-name)))))\n    (save-excursion\n      (save-restriction\n	(widen)\n	(let ((alist template-update-buffer-alist)\n	      (case-fold-search (memq system-type '(vax-vms ms-dos windows-nt)))\n	      stamp prompt region new)\n	  (while alist\n	    (setq stamp (pop alist))\n	    (condition-case nil\n		(and (template-match-modes-or-regexp (pop stamp))\n		     ;; Run TEST ---------------------------------------------\n		     (setq prompt (pop stamp)\n			   region (pop stamp) ; TEST\n			   region (eval (if (or (atom region)\n						(functionp (car region)))\n					    region\n					  (cons 'template-update-buffer-region\n						region))))\n		     (if (stringp (setq new (eval (pop stamp))))\n			 (null (string= (buffer-substring (car region)\n							  (cdr region))\n					new))\n		       (car stamp))\n		     ;; user confirmation, replacement -----------------------\n		     (or (null prompt)\n			 arg\n			 (eq template-auto-update t)\n			 (y-or-n-p (format prompt (buffer-name))))\n		     (progn\n		       (goto-char (car region))\n		       (if (car stamp)\n			   (funcall (car stamp) new (car region) (cdr region))\n			 (delete-region (car region) (cdr region))\n			 (insert new))))\n	      (error nil))))))))\n\n\n;;;===========================================================================\n;;;  Update header\n;;;===========================================================================\n\n;;;###autoload\n(defun template-update-header (&optional show)\n  \"Replace old file name in header with current file name.\nIf SHOW is t, just return region of the filename or nil.  Otherwise,\nreplace filename if possible and signal an error if SHOW is nil and\nthere is no filename in the header.  See `template-header-lines' and\n`template-header-regexp-alist'.\"\n  (interactive \"*P\")\n  (if buffer-file-name\n      (save-excursion\n	(goto-char (point-min))\n	(let ((case-fold-search nil)\n	      (comment-regexp (template-default-comment)) ; at `point-min'!\n	      (end (progn (forward-line template-header-lines) (point)))\n	      (alist template-header-regexp-alist)\n	      (disallowed \"\")\n	      group)\n	  (if (string-match \"[A-Za-z]\\\\|..\" comment-regexp)\n	      (setq comment-regexp (regexp-quote comment-regexp)\n		    disallowed \"\")\n	    (or (eq comment-regexp '(?\\]))\n		(setq disallowed comment-regexp))\n	    (setq comment-regexp (concat (regexp-quote comment-regexp) \"+\")))\n	  (while alist\n	    (goto-char (point-min))\n	    (if (re-search-forward (format (caar alist)\n					   comment-regexp disallowed)\n				   end t)\n		(setq group (cdar alist)\n		      alist nil)\n	      (setq alist (cdr alist))))\n	  (if (and group (match-beginning group))\n	      (if (eq show t)\n		  (cons (match-beginning group) (match-end group))\n		(goto-char (match-beginning group))\n		(delete-region (point) (match-end group))\n		(insert (file-name-sans-versions\n			 (file-name-nondirectory buffer-file-name)))\n		t)\n	    (if show nil (error \"No file name in header\")))))\n    (if show nil (error \"Buffer is not visiting a file\"))))\n\n\n\f\n;;;;##########################################################################\n;;;;  Templates\n;;;;##########################################################################\n\n\n(defvar template-history nil\n  \"History, used by `template-read'.\")\n\n(defvar template-choice-history nil\n  \"History, used by `template-choice'.\")\n\n(put 'normal-mode 'template-secure-command t)\n\n(defvar template-all-templates nil\n  \"Internal variable.  Template files used for template derivation.\")\n(defvar template-file nil\n  \"Partitioned name of new file: (DIR FILE RAW NUMBER EXT).\nInternal variable.  DIR is the directory part, FILE the file name\nwithout directory part.  FILE consists of its extension EXT, RAW and a\nnumbering NUMBER just in front of the extension.  It is used by the\nexpansions DIR, FILE, FILE_SANS, FILE_EXT and others in\n`template-expansion-alist'.  Also useful for user defined functions in\n`template-derivation-alist' and the per-template definition section.\")\n\n(defvar template-modified nil\n  \"Internal variable.  Whether user is asked during the expansion process.\")\n(defvar template-secure t\n  \"Internal variable.  Whether all per-template definitions are secure.\")\n(defvar template-point-messages nil\n  \"Internal variable.  List of lines for temporary message at point.\")\n(defvar template-before-messages nil\n  \"Internal variable.  List of lines for temporary message before expansion.\")\n(defvar template-after-messages nil\n  \"Internal variable.  List of lines for temporary message after expansion.\")\n\n(defvar template-point nil\n  \"Internal variable.  Position of point.  Set with expansion form P.\")\n(defvar template-mark nil\n  \"Internal variable.  Position of mark.  Set with expansion form M.\")\n\n(defvar template-current nil\n  \"Internal variable.  Current key of expansion form.\")\n(defvar template-string-alist nil\n  \"Internal variable.  Alist of user inputs for `template-read'.\")\n(defvar template-register-alist nil\n  \"Internal variable.  Alist of used registers.\")\n(defvar template-local-alist nil\n  \"Internal variable.  Alist of per-template defined expansions.\")\n\n(defvar template-ffap-file-finder nil\n  \"Value used inside `template-ffap-find-file'.\nIf nil, initialize it to the value of `ffap-file-finder', i.e., this\nvariable holds the original value of that variable which will be set to\n`template-ffap-find-file' in `template-initialize'.\")\n\n\n;;;===========================================================================\n;;;  Functions: `find-file'/`insert-file-contents', hooking into `find-file'\n;;;===========================================================================\n\n(defun template-find-template (filename &optional replace)\n  \"Switch to a buffer visiting template file FILENAME.\nIf optional REPLACE is non-nil, replace the current buffer contents with\nthe contents of file FILENAME.\n\nThis function always considers template files as text files.\"\n  (let ((file-name-buffer-file-type-alist nil))	; Emacs on DOS/NT\n    (if replace\n	(insert-file-contents filename nil nil nil\n			      ;; 5th arg not t with empty accessible part\n			      ;; (XEmacs bug workaround: would infloop)\n			      (> (point-max) (point-min)))\n      (let ((template-auto-insert nil))\n	(switch-to-buffer (find-file-noselect filename))))))\n\n(defun template-not-found-function ()\n  \"Use a template when visiting a non-existent file.\nSee `template-auto-insert' and `template-find-file-commands'.  Function\nin `find-file-not-found-hooks'.\"\n  (and template-auto-insert (not buffer-read-only) (bobp) (eobp)\n       (or (memq this-command template-find-file-commands)\n	   (and (memq this-command template-file-select-commands)\n		;; thanks to Dave Love <d.love@dl.ac.uk>:\n		(memq (car-safe (car command-history))\n		      ;; To always include `find-file-at-point', use ffap\n		      ;; initialization (see `template-ffap-find-file')\n		      template-find-file-commands)))\n       (let ((template (cdr (template-derivation buffer-file-name t t))))\n	 (and template\n	      (file-readable-p template)\n	      (or (eq template-auto-insert t)\n		  (y-or-n-p\n		   (format \"Use template %s? \"\n			   (cond-emacs-xemacs\n			    (abbreviate-file-name template :XEMACS t)))))\n	      (progn\n		(template-new-file nil template)\n		(setq this-command 'session-disable)\n		t)))))\n\n(defun template-ffap-find-file (filename)\n  \"Function to use in `ffap-file-finder'.\nAdd an entry to `command-history' if necessary and call function in\n`template-ffap-file-finder' with argument FILENAME.\"\n  (or (memq (car-safe (car command-history))\n	    '(ffap find-file-at-point))\n      (setq command-history\n	    (cons (list 'find-file-at-point filename) command-history)))\n  (if (eq template-ffap-file-finder 'template-ffap-find-file)\n      (find-file filename)\n    (funcall template-ffap-file-finder filename)))\n\n\n;;;===========================================================================\n;;;  Main function\n;;;===========================================================================\n\n(defun template-expand-template-interactive ()\n  (let* ((use (template-derivation (expand-file-name\n				    (or buffer-file-name \"NONE\"))\n				   t))\n	 (tpl (read-file-name \"Insert and expand template: \"\n			      (file-name-directory (cdr use))\n			      (file-name-nondirectory (cdr use))\n			      t\n			      (file-name-nondirectory (cdr use)))))\n    (if (string= tpl \"\")\n	(error \"No template file provided\"))\n    (list (expand-file-name tpl (file-name-directory (cdr use))))))\n\n;;;###autoload\n(defun template-expand-template (template)\n  \"Expand template file TEMPLATE and insert result in current buffer.\nUsing a template for inserting some text consists of:\n  1. Template derivation: suggest a reasonable template file to the user\n     according to `buffer-file-name', see `template-derivation-alist'.\n  2. Template insertion: insert the template file at point into the\n     current buffer.\n  3.. as steps 6.. of `template-new-file'.\"\n  (interactive (template-expand-template-interactive))\n  (save-restriction\n    (narrow-to-region (point) (point))\n    (template-new-file nil template t)))\n\n(defun template-new-file-interactive ()\n  \"Interactive specification for `template-new-file'.\nReturn \\(FILE TEMPLATE).\"\n  (let* ((inp (read-file-name (if current-prefix-arg\n				  \"New file (+template, no name change): \"\n				\"New file (+template): \")\n			      nil \"\"))\n	 (use (cond ((equal inp \"\")\n		     (error \"Empty/no input\"))\n		    ((file-directory-p inp)\n		     (error \"%S is a directory\" inp))\n		    (t (template-derivation (expand-file-name inp)\n					    current-prefix-arg))))\n	 (tpl (read-file-name (format \"File %s uses template: \"\n				      (file-name-nondirectory (car use)))\n			      (file-name-directory (cdr use))\n			      (file-name-nondirectory (cdr use))\n			      t\n			      (file-name-nondirectory (cdr use)))))\n    (list (car use)\n	  (if (string= tpl \"\")\n	      nil\n	    (expand-file-name tpl (file-name-directory (cdr use)))))))\n\n;;;###autoload\n(defun template-new-file (file template &optional with-undo)\n  \"Open a new file FILE by using a TEMPLATE.\nUsing a template for creating a new file consists of, steps 1 to 3 are\nonly executed when called interactively:\n  1. Prompt for the name of the new file.\n  2. Template derivation: suggest a reasonable template file to the user\n     see `template-derivation-alist'.\n  3. File name refinement: e.g., if the given file name is \\\"exercise\\\"\n     and there are two files \\\"exercise1.tex\\\" and \\\"exercise2.tex\\\" in\n     the same directory and if we have a template \\\"exercise.tex.tpl\\\",\n     the file name is refined to \\\"exercise3.tex\\\".  This is turned off\n     when \\\\[template-new-file] is called with a prefix argument.\n  4. Template insertion: insert the template file into the empty buffer.\n  5. Read per-template expansion definition section starting at\n     `template-definition-start' and delete it.\n  6. Display :before message in `template-message-buffer'.\n  7. Execute pre-expansion commands defined in the definition section.\n  8. Set local variables defined in the definition section.\n  9. Expansion: expand the expansion forms (text matched by\n     `template-expansion-regexp') They are defined in the definition\n     section, in `template-expansion-alist', or provided by default, see\n     `template-expansion-regexp' and `template-register-regexp'.\n 10. Execute post-expansion commands defined in the definition section.\n 11. Run `normal-mode' and functions in `find-file-hooks'.\n 12. Update header according to `template-update-header' with argument\n    `if-exists'.\n 13. Display :after message in `template-message-buffer'.\n 14. Report: display a temporary message at point defined in the\n     definition section and an automatically generated message in the\n     minibuffer area, see `template-message-timeout'.\n\nIf optional WITH-UNDO is non-nil, store corresponding changes in\n`buffer-undo-list'.  If FILE is nil, the buffer for FILE has already\nbeen created and the accessible part will be replaced by the expanded\ntemplate.  If TEMPLATE is nil (empty input when called interactively),\ndo not use a template.\"\n  (interactive (template-new-file-interactive))\n  ;; check template and file name --------------------------------------------\n  (if template\n      (if (file-readable-p template)\n	  (if (file-directory-p template)\n	      (error \"Template %s is a directory\" template))\n	(if (null (yes-or-no-p (format \"Template %s does not exist.  Create? \"\n				       template)))\n	    (error \"No template file to use\")\n	  (template-make-directory (file-name-directory template))\n	  (template-find-template template)\n	  (error \"You should create this template first\"))))\n  (if (not file)\n      (switch-to-buffer (current-buffer))\n    (and (or (get-file-buffer file) (file-exists-p file))\n	 (null (yes-or-no-p (format \"File %s exists.  Delete contents? \" file)))\n	 (error \"Cannot use templates for existing files\"))\n    (let ((auto-mode-alist nil)\n	  (enable-local-variables nil)\n	  (find-file-not-found-hooks nil)\n	  (enable-local-eval nil))\n      (switch-to-buffer (find-file-noselect file))))\n  (when template\n    (or with-undo (setq buffer-undo-list t))\n    (template-find-template template t)\n    (template-new-file-0 with-undo)))\n\n(defun template-new-file-0 (with-undo)\n  \"Perform template replacements in current buffer.\nIf WITH-UNDO is non-nil, store corresponding changes in\n`buffer-undo-list'.\"\n  ;; start replacement -------------------------------------------------------\n  (or with-undo (set-buffer-modified-p nil))\n  (goto-char (point-min))\n  (setq template-secure t\n	template-point nil\n	template-mark nil\n	template-modified nil\n	template-point-messages nil\n	template-before-messages nil\n	template-after-messages nil\n	template-local-alist nil\n	template-register-alist nil\n	template-string-alist nil)\n  (let ((form-selector nil)\n	(pre-command-list nil)\n	(post-command-list nil)\n	(local-variable-list nil)\n	val)\n    ;; read per-template definition section ----------------------------------\n    (goto-char (point-min))\n    (when (re-search-forward\n	   (concat \"^[ \\t]*\" template-definition-start \"[ \\t]*$\") nil t)\n      (condition-case ()\n	  (while t\n	    (setq val (read (current-buffer)))\n	    (cond (;; (\"KEY\" . xxx): ask user --------------------------------\n		   (and (consp val) (stringp (car val)))\n		   (let* ((def (cdr val)) ; expansion forms\n			  (msg (cond ((null template-message-prompt-format)\n				      nil)\n				     ((stringp def) def)\n				     ((and (consp def) (stringp (car def)))\n				      (car def)))))\n		     (when msg		; list prompts in before-messages\n		       (or template-before-messages\n			   (null template-message-prompt-intro)\n			   (push template-message-prompt-intro\n				 template-before-messages))\n		       (push (format template-message-prompt-format msg)\n			     template-before-messages))\n		     (push (cons (car val) (template-translate-definition def))\n			   template-local-alist)))\n		  ;; :before, :after, :eval-before, :eval-after --------------\n		  ((null val)		; nil is deprecated\n		   (setq form-selector\n			 (cond ((null form-selector) :old-before)\n			       ((eq form-selector :old-before) :old-after)\n			       ((eq form-selector :old-after)\n				(error \"More than two (obsolete) nil forms\"))\n			       (t\n				(error \"Used obsolete nil form with new form selectors\")))))\n		  ((memq val '(:before :after :eval-before :eval-after))\n		   (setq form-selector val))\n		  ;; \"MESSAGE\" -----------------------------------------------\n		  ((stringp val)\n		   (cond ((eq form-selector :before)\n			  (push val template-before-messages))\n			 ((eq form-selector :after)\n			  (push val template-after-messages))\n			 (t\n			  (push val template-point-messages))))\n		  ;; (CHAR . xxx): set register ------------------------------\n		  ((and (consp val) (template-char-or-char-int-p (car val)))\n		   (let ((reg (template-char-or-int-to-char (car val))))\n		     (if (atom (cdr val))\n			 (set-register reg (cdr val))\n		       (set-register reg (cadr val))\n		       (when template-message-register-format\n			 (let ((msg (format template-message-register-format\n					    reg (cadr val)\n					    (or (caddr val) \"\"))))\n			   (if template-message-buffer\n			       (progn\n				 (if template-before-messages\n				     (push msg template-before-messages))\n				 (or template-after-messages\n				     (null template-message-register-intro)\n				     (push template-message-register-intro\n					   template-after-messages))\n				 (push msg template-after-messages))\n			     (push msg template-point-messages)))))))\n		  ;; set var, execute command and sexpr ----------------------\n		  ((and (memq form-selector '(nil :before :after))\n			(consp val)\n			(symbolp (car val)))\n		   (or (and (functionp (get (car val) 'template-secure-value))\n			    (funcall (get (car val) 'template-secure-value)\n				     (cdr val)))\n		       (setq template-secure nil))\n		   (push val local-variable-list))\n		  ((memq form-selector '(:eval-before :old-before))\n		   (push (template-elisp-in-definition val)\n			 pre-command-list))\n		  ((memq form-selector '(:eval-after :old-after))\n		   (push (template-elisp-in-definition val)\n			 post-command-list))\n		  (t\n		   (error \"Illegal form\"))))\n	(error nil))\n      (skip-chars-forward \" \\t\\n\\f\")\n      (or (eobp)\n	  (error \"Invalid definition in line %d (pos %d) of the template file\"\n		 (count-lines 1 (point)) (point)))\n      (or template-secure\n	  (null (default-value template-confirm-insecure))\n	  (y-or-n-p \"Have you checked the template functions? \")\n	  (error \"Failed security check\"))\n      (delete-region (match-beginning 0) (point-max)))\n    ;; expand ----------------------------------------------------------------\n    (template-display-messages template-before-messages)\n    (eval (cons 'progn (nreverse pre-command-list)))\n    (while local-variable-list\n      (make-local-variable (caar local-variable-list))\n      (set (caar local-variable-list) (cdar local-variable-list))\n      (setq local-variable-list (cdr local-variable-list)))\n    (goto-char (point-min))\n    (while (re-search-forward template-expansion-regexp nil t)\n      (setq template-current (buffer-substring (match-beginning 1)\n					       (match-end 1))\n	    val (assoc template-current template-local-alist))\n      (unless val\n	(if (setq val (assoc template-current template-key-alias-alist))\n	    (setq template-current (cdr val)))\n	(setq val (or (assoc template-current template-expansion-alist)\n		      (assoc template-current\n			     template-default-expansion-alist))))\n      (delete-region (match-beginning 0) (match-end 0))\n      (cond (val\n	     (eval (cons 'progn (cdr val))))\n	    ((string-match template-register-regexp template-current)\n	     (template-register))\n	    (t\n	     (template-read (format \"Replacement for `%s': \"\n				    template-current)))))\n    (eval (cons 'progn (nreverse post-command-list)))\n    (save-restriction\n      (widen)\n      (normal-mode t)\n      (or with-undo (template-update-header 'if-exists))\n      (run-hooks 'find-file-hooks))\n    ;; message ---------------------------------------------------------------\n    (template-display-messages template-after-messages)\n    (cond ((null template-register-alist)\n	   (message \"%s, no buffer location in register\"\n		    (if template-mark \"Mark set\" \"No mark\")))\n	  (t (message \"%s, buffer location in register: %s\"\n		      (if template-mark \"Mark set\" \"No mark\")\n		      (mapconcat (function\n				  (lambda (x)\n				    (if (cdr x)\n					(concat (char-to-string (car x)) \"*\")\n				      (char-to-string (car x)))))\n				 (nreverse template-register-alist)\n				 \", \"))))\n    (or with-undo (set-buffer-modified-p template-modified))\n    (goto-char (point-min))\n    (when template-point\n      (goto-char template-point)\n      (set-marker template-point nil))\n    (when template-mark\n      (push-mark template-mark)\n      (set-marker template-mark nil)\n      (if (fboundp 'zmacs-activate-region) (zmacs-activate-region)))\n    (when (and template-point-messages\n	       (or (cdr template-point-messages)\n		   (not (string-equal (car template-point-messages) \"\"))))\n      (let ((beg (point))\n	    end)\n	(if (cdr template-point-messages)\n	    (insert (mapconcat 'identity\n			       (nreverse template-point-messages)\n			       \"\\n\")\n		    \"\\n\")\n	  (insert (car template-point-messages)))\n	(setq end (point))\n	(goto-char beg)\n	(and (fboundp 'make-extent) (fboundp 'set-extent-face)\n	     (set-extent-face (make-extent beg end) 'template-message-face))\n	(recenter)\n	(sit-for template-message-timeout)\n	(delete-region beg end))))\n  (recenter)\n  (unless with-undo\n    (setq buffer-undo-list nil)\n    (set-buffer-modified-p template-modified)))\n\n(defun template-display-messages (messages)\n  (when (and messages template-message-buffer)\n    (setq messages (nreverse messages))\n    (with-output-to-temp-buffer template-message-buffer\n      (while messages\n	(princ (pop messages))\n	(if messages (princ \"\\n\"))))))\n\n\n;;;===========================================================================\n;;;  Determine name of the new file and the template\n;;;===========================================================================\n\n(defun template-derivation (full arg &optional no-default)\n  \"Derive template file name and do file name refinement.\nReturn (REFINED . TEMPLATE) where REFINED is the refined version of FULL\nand TEMPLATE and template file name, see `template-derivation-alist'.\nFULL is the initial file name given by the user.  File name refinement\nis turned off when ARG is non-nil.  If optional argument NO-DEFAULT is\nnon-nil, return nil instead (FULL \\. \\\"~/.emacs.d/templates/DEFAULT.tpl\\\") if no\nmatching entry can be found in `template-derivation-alist'.\"\n  ;; Get all templates -------------------------------------------------------\n  (setq template-all-templates nil)\n  (let* ((dir (file-name-directory full))\n	 (len (length dir))\n	 (case-fold-search (memq system-type '(vax-vms ms-dos windows-nt))))\n    (while (and dir\n		(not (and template-stop-derivation\n			  (fboundp template-stop-derivation)\n			  (funcall template-stop-derivation dir))))\n      (template-all-templates template-subdirectories dir)\n      (setq dir (file-name-directory (directory-file-name dir)))\n      (or (> len (setq len (length dir)))\n	  (setq dir nil)))\n    (template-all-templates template-default-directories)\n    (setq template-all-templates (nreverse template-all-templates)))\n  ;; Get template file -------------------------------------------------------\n  (if (string= (file-name-nondirectory full) \"\")\n      (error \"You cannot use templates for directories\"))\n  (setq template-file (template-split-filename full))\n  (let ((tests template-derivation-alist)\n	test template file)\n    (while tests\n      (setq test (caar tests)\n	    file (cdar tests))\n      (if (setq template\n		(if (functionp (car test))\n		    (apply (car test) (cdr test))\n		  (apply 'template-default-template test)))\n	  (setq tests nil)\n	(setq tests (cdr tests))))\n    (if template\n	(or arg\n	    (if (functionp (car file))\n		(apply (car file) template (cdr file))\n	      (apply 'template-unique-file template file)))\n      (or no-default\n	  (setq template (template-split-filename\n			  \"DEFAULT\"\n			  (template-default-directory)))))\n    (if template\n	(cons (expand-file-name (cadr template-file) (car template-file))\n	      (expand-file-name (concat (cadr template) template-extension)\n				(car template))))))\n\n(defun template-default-directory ()\n  \"Return directory of file \\\"DEFAULT.tpl\\\".\"\n  (let ((dirs template-default-directories)\n	(name (concat \"DEFAULT\" template-extension))\n	dir)\n    (while dirs\n      (setq dir (pop dirs))\n      (if (file-readable-p (expand-file-name name dir))\n	  (setq dirs nil)\n	(setq dir nil)))\n    (or dir\n	(car template-default-directories)\n	(expand-file-name \"~/.emacs.d/templates/\"))))\n\n\n;;;===========================================================================\n;;;  Small functions\n;;;===========================================================================\n\n(defun template-make-directory (dir)\n  \"Create DIR if it does not exists yet.\"\n  (cond ((file-exists-p dir))\n	((yes-or-no-p (format \"The directory %s does not exist.  Create? \" dir))\n	 (make-directory dir t))\n	(t (error \"You should create a directory \\\"%s\\\"\" dir)))\n  dir)\n\n(defun template-split-filename (file &optional dir)\n  \"Split file name into its parts.\nIf DIR is nil, FILE is a fully expanded file name, otherwise FILE is a\nfile name without its directory part DIR.  See `template-file'.\"\n  (or dir (setq dir (template-make-directory (file-name-directory file))\n		file (file-name-nondirectory file)))\n  (let* ((ext (string-match \"\\\\.[^.]*\\\\'\" file))\n	 (raw (substring file 0 ext))\n	 (num (string-match \"[^0-9][0-9]+\\\\'\" raw)))\n    (if num\n	(list dir file\n	      (substring raw 0 (1+ num))\n	      (substring raw (1+ num))\n	      (if ext (substring file ext) \"\"))\n      (list dir file raw \"\" (if ext (substring file ext) \"\")))))\n\n(defun template-translate-definition (def)\n  \"Translate DEF of expansion and set `template-secure' accordingly.\"\n  (cond ((null def) ; zero form\n	 nil)\n	((template-char-or-char-int-p def)\n	 `((template-register ,def)))\n	((stringp def)\n	 `((template-read ,def nil nil nil t)))\n	((symbolp def)\n	 `((insert (if (stringp ,def) ,def template-string-default))))\n	((and (consp def) (stringp (car def)))\n	 (if (consp (car-safe (cdr def)))\n	     `((template-choice ,(car def) (quote ,(cdr def))))\n	   `((apply (quote template-read) (quote ,def)))))\n	((consp (car-safe def))\n	 (setq template-secure nil)\n	 def)\n	(t\n	 (list (template-elisp-in-definition (car def) (cdr def))))))\n\n(defun template-elisp-in-definition (def &optional prefix)\n  \"Return valid elisp definition and set `template-secure' accordingly.\nDEF is the elisp form, PREFIX would be the prefix argument if DEF is a\ncommand.\"\n  (cond ((consp def)\n	 (setq template-secure nil)\n	 def)\n	((or (symbolp def) (vectorp def))\n	 (or (and (symbolp def) (get def 'template-secure-command))\n	     (setq template-secure nil))\n	 (if (and (symbolp def)\n		  (functionp (get def 'template-secure-command))\n		  (listp prefix)\n		  (funcall (get def 'template-secure-command) prefix))\n	     `(apply (quote ,def) (quote ,prefix))\n	   `(progn (setq prefix-arg (quote ,prefix))\n		   (command-execute (quote ,def)))))\n	(t\n	 (error \"Illegal form\"))))\n\n\n;;;===========================================================================\n;;;  Compute template name\n;;;===========================================================================\n\n(defun template-all-templates (dirs &optional base)\n  \"Read names of template files in DIRS relatively to BASE.\nInsert the names to internal variable `template-all-templates'.\"\n  (let ((regexp (concat (regexp-quote template-extension) \"\\\\'\"))\n	(endpos (- (length template-extension)))\n	dir templates)\n    (while dirs\n      (setq dir (expand-file-name (car dirs) base)\n	    dirs (cdr dirs))\n      (cond-emacs-xemacs\n       (and (file-accessible-directory-p dir)\n	    (file-readable-p dir)\n	    (setq templates (directory-files dir t regexp :XEMACS nil t))\n	    (while templates\n	      (and :EMACS\n		   (not (file-directory-p (car templates)))\n		   :BOTH\n		   (file-readable-p (car templates))\n		   (push (template-split-filename (substring (car templates)\n							     0\n							     endpos))\n			 template-all-templates))\n	      (setq templates (cdr templates))))))))\n\n(defun template-set-template-part (part file-part)\n  \"Set template part according to definition PART and FILE-PART.\nSee `template-derivation-alist' for details.\"\n  (when part\n    (cond ((stringp part) part)\n	  ((eq part t) file-part)\n	  ((null (string= file-part \"\")) file-part))))\n\n(defun template-default-template (&optional raw num ext regexp)\n  \"Return template according to RAW, NUM, EXT and REGEXP.\nSee `template-derivation-alist' for details.\"\n  (if (or (null regexp) (string-match regexp (cadr template-file)))\n      (let ((templates template-all-templates)\n	    (file-rne (cddr template-file))\n	    result template-rne)\n	(setq raw (template-set-template-part raw (car file-rne))\n	      num (template-set-template-part num (cadr file-rne))\n	      ext (template-set-template-part ext (caddr file-rne)))\n	(while templates\n	  (setq template-rne (cddar templates))\n	  (if (and (or (null raw) (string= (car template-rne) raw))\n		   (or (null num) (string= (cadr template-rne) num))\n		   (or (null ext) (string= (caddr template-rne) ext)))\n	      (setq result (car templates)\n		    templates nil)\n	    (setq templates (cdr templates))))\n	result)))\n\n\n;;;===========================================================================\n;;;  File name refinement\n;;;===========================================================================\n\n(defun template-default-file (template &optional raw num ext)\n  \"Refine file name according to TEMPLATE, RAW, NUM and EXT.\nThe result is in `template-file'.  See `template-derivation-alist'.\"\n  (let ((template-rne (cddr template))\n	(file-rne (cddr template-file)))\n    (if raw\n	(if (eq raw t) (setq raw (car template-rne)))\n      (setq raw (car file-rne)))\n    (if num\n	(if (eq num t) (setq num (cadr template-rne)))\n      (setq num (cadr file-rne)))\n    (if ext\n	(if (eq ext t) (setq ext (caddr template-rne)))\n      (setq ext (caddr file-rne)))\n    (setcdr template-file (list (concat raw num ext) raw num ext))))\n\n(defunx template-unique-file (template &optional raw num ext auto-num)\n  \"Refine file name according to TEMPLATE, RAW, NUM, EXT and AUTO-NUM.\nUse auto numbering if NUM is not \\\"\\\" or AUTO-NUM is non-nil.  The\nresult is in `template-file'.  See `template-derivation-alist'.\"\n  (template-default-file template raw num ext)\n  (let* ((dir (car template-file))\n	 (full (expand-file-name (cadr template-file) dir)))\n    (when (if (string= (fourth template-file) \"\")\n	      auto-num\n	    (setq auto-num\n		  (and (or (get-file-buffer full)\n			   (file-readable-p full))\n		       (string-to-int (fourth template-file)))))\n      (setq auto-num (1- auto-num)\n	    raw (third template-file)\n	    ext (fifth template-file))\n      (let ((list (buffer-list))\n	    file1 dir1)\n	(while list\n	  (and (setq file1 (buffer-file-name (car list)))\n	       (setq dir1 (file-name-directory file1))\n	       (string= dir1 dir)\n	       (setq auto-num\n		     (max (template-filename-number\n			   (cddr (template-split-filename\n				  (file-name-nondirectory file1)\n				  dir1))\n			   raw ext)\n			  auto-num)))\n	  (setq list (cdr list)))\n	(setq list (directory-files dir nil nil t :XEMACS t))\n	(while list\n	  (unless (:EMACS file-directory-p (car list))\n	    (setq auto-num\n		  (max (template-filename-number\n			(cddr (template-split-filename (car list) dir))\n			raw ext)\n		       auto-num)\n		  list (cdr list))))\n	(template-default-file template raw\n			       (int-to-string (1+ auto-num))\n			       ext)))))\n\n(defun template-filename-number (file-rne raw ext)\n  \"Return numbering in FILE-RNE if the RAW and EXT parts are equal.\"\n  (or (and (string= (car file-rne) raw)\n	   (string= (caddr file-rne) ext)\n	   (string-to-int (cadr file-rne)))\n      0))\n\n\n;;;===========================================================================\n;;;  Safe commands for per-template expansions\n;;;===========================================================================\n\n(defun template-insert-time (&optional format default)\n  \"Insert time into current buffer using time format FORMAT.\nIf FORMAT is not a string, it uses DEFAULT or `current-time-string'.\"\n  (interactive)\n  (insert (if (and (stringp format) (fboundp 'format-time-string))\n	      (format-time-string format (current-time))\n	    (or default (current-time-string)))))\n(put 'template-insert-time 'template-secure-command\n     (lambda (args)\n       (or (null args) (and (stringp (car args)) (null (cdr args))))))\n\n\n;;;===========================================================================\n;;;  Functions for the predefined expansions\n;;;===========================================================================\n\n(defun template-register (&optional register)\n  \"Set current location in register REGISTER.\nThat is, \\\\[jump-to-register] REGISTER jumps to the current position.\nIf REGISTER is nil, use register corresponding to the last character in\n`template-current'.\"\n  (let* ((char (if register\n		   (template-char-or-int-to-char register)\n		 (aref template-current (1- (length template-current)))))\n	 (elem (assoc char template-register-alist)))\n    (point-to-register char)\n    (if elem\n	(setcdr elem t)\n      (push (list char) template-register-alist))))\n\n(defun template-read (prompt &optional prefix suffix default again-p)\n  \"Ask user with PROMPT for a STRING to be inserted.\nIf STRING is not \\\"\\\", insert PREFIX STRING SUFFIX, otherwise DEFAULT.\nIf AGAIN-P is nil, do not ask if `template-current' appears another time\nas key in a expansion form.  If AGAIN-P is `expand', the inserted region\nis searched for expansion forms where STRING is marked as a literal\nenvironment, see `template-literal-environment'.\"\n  (setq template-modified t)\n  (let ((pos (point))\n	(elem (and (null again-p)\n		   (assoc template-current template-string-alist))))\n    (if elem\n	(setq elem (cdr elem))\n      (setq elem (read-from-minibuffer prompt nil nil nil\n				       'template-history)\n	    elem (cond ((string= elem \"\") (or default \"\"))\n		       ((eq again-p 'expand)\n			(concat prefix\n				(format template-expansion-format\n					(car template-literal-environment))\n				elem\n				(format template-expansion-format\n					(cdr template-literal-environment))\n				suffix\n				(format template-expansion-format\n					(car template-literal-environment))\n				(format template-expansion-format\n					(cdr template-literal-environment))))\n		       (t\n			(concat prefix elem suffix))))\n      (or again-p (push (cons template-current elem) template-string-alist)))\n    (insert elem)\n    (if (eq again-p 'expand) (goto-char pos))))\n\n(defun template-choice (prompt table)\n  \"Ask user with PROMPT for a choice and insert it.\nEach element in TABLE looks like (ANSWER . TEXT).  Ask for an input with\ncompletion over all ANSWERs and insert corresponding TEXT if ANSWER is a\nstring, otherwise ask a \\\"y or n\\\" question and use the result of\n`y-or-n-p' as ANSWER.  Expansion forms in TEXT will be expanded.\"\n  (setq template-modified t)\n  (let ((pos (point)))\n    (insert (or (cdr (assoc (if (stringp (caar table))\n				(completing-read prompt table nil t nil\n						 'template-choice-history)\n			      (y-or-n-p prompt))\n			    table))\n		\"\")\n	    (format template-expansion-format\n		    (car template-literal-environment))\n	    (format template-expansion-format\n		    (cdr template-literal-environment)))\n    (goto-char pos)))\n\n\n;;;===========================================================================\n;;;  Menu filter\n;;;===========================================================================\n\n(defun template-menu-filter (menu-items)\n  ;; checkdoc-params: (menu-items)\n  \"Menu filter for `template-creation-menu'.\"\n  (let ((alist (append template-expansion-alist\n		       template-default-expansion-alist))\n	menu used key)\n    (while alist\n      (unless (member (setq key (car (pop alist))) used)\n	(push key used)\n	(push (vector (concat \"Insert \" key)\n		      (list 'template-insert-form current-prefix-arg key)\n		      t)\n	      menu)))\n    (append menu-items (nreverse menu))))\n\n\n;;;===========================================================================\n;;;  Insert and define forms\n;;;===========================================================================\n\n(defun template-buffer-template-p ()\n  \"Return non-nil, if current buffer is likely to be a template file.\"\n  (and buffer-file-name\n       (string-match (concat (regexp-quote template-extension) \"\\\\'\")\n		     (file-name-sans-versions buffer-file-name))))\n\n(defun template-open-template ()\n  \"If current buffer is no template file, open a new one.\"\n  (interactive)\n  (if (template-buffer-template-p)\n      (barf-if-buffer-read-only)\n    (let (name\n	  (dir (and (car template-subdirectories)\n		    (expand-file-name (car template-subdirectories)))))\n      (if (null buffer-file-name)\n	  (setq name (concat \"TEMPLATE\" template-extension))\n	(setq name (file-name-sans-versions\n		    (file-name-nondirectory buffer-file-name)))\n	(if (string-match \".\\\\.[^.]*\\\\'\" name)\n	    (setq name (concat \"TEMPLATE\"\n			       (substring name (1+ (match-beginning 0)))\n			       template-extension))\n	  (setq name (concat name template-extension)\n		;; dot file => template not specific for directory\n		dir (car template-default-directories))))\n      (setq name (read-file-name \"Open template file (empty=none): \"\n				 dir nil nil name))\n      (or (string= name \"\")\n	  (template-find-template name)))))\n\n(defun template-insert-form (arg key)\n  \"Insert an expansion form according to KEY into template.\nWhen called interactively, allow completion over all keys in\n`template-expansion-alist' and `template-default-expansion-alist'.\nIf prefix ARG is nil, run `template-open-template' first.\"\n  (interactive\n   (list current-prefix-arg\n	 (completing-read \"Insert key (0-9 for register position): \"\n			  (append template-expansion-alist\n				  template-default-expansion-alist))))\n  (or arg (template-open-template))\n  (insert (format template-expansion-format key))\n  (if (equal key (car template-literal-environment))\n      (let ((pos (point)))\n	(insert (format template-expansion-format\n			(cdr template-literal-environment)))\n	(goto-char pos))))\n\n(defun template-define-start (arg &rest args)\n  \"Insert a definition section and definition into template.\nSee `template-definition-start'.  If ARGS is non-nil, pass ARGS to\n`format' for a new definition.  If prefix ARG is nil, run\n`template-open-template' first.\"\n  (interactive \"P\")\n  (or arg (template-open-template))\n  (save-excursion\n    (goto-char (point-min))\n    (unless (re-search-forward (concat \"^[ \\t]*\"\n				       template-definition-start\n				       \"[ \\t]*$\") nil t)\n      (goto-char (point-max))\n      (or (bolp) (insert \"\\n\"))\n      (insert template-definition-start))\n    (goto-char (point-max))\n    (or (bolp) (insert \"\\n\"))\n    (if args (insert (apply 'format args) \"\\n\")))\n  (message \"Put definition at the end of the template\"))\n\n(defun template-define-message (arg message)\n  \"Insert a temporary message MESSAGE definition into template.\nFor ARG, see `template-define-start'.\"\n  (interactive \"P\\nsTemporary message: \")\n  (template-define-start arg \"%S\" message))\n\n(defun template-define-prompt (arg key prompt &optional prefix suffix default)\n  \"Insert a definition for KEY as PROMPT into template.\nFor ARG, see `template-define-start'.\"\n  (interactive \"P\\nsExpansion key: \\nsExpansion prompt: \\nsPrefix for non-empty input: \\nsSuffix for non-empty input: \\nsDefault for empty input: \")\n  (template-define-start arg \"(%S %S %S %S %S)\"\n			 key prompt prefix suffix default))\n\n(defun template-define-register (arg register)\n  \"Insert a setting of REGISTER into template.\nFor ARG, see `template-define-start'.\"\n  (interactive \"P\\ncDefine register: \")\n  (let* ((old (get-register register))\n	 (contents (read-from-minibuffer \"Register contents: \"\n				    (and (stringp old)\n					 (not (string-match \"\\n\" old))\n					 old)))\n	 (comment (read-from-minibuffer \"Comment (empty=none): \")))\n    (if (string= comment \"\")\n	(template-define-start arg \"(%S %S)\" register contents)\n      (template-define-start arg \"(%S %S %S)\" register contents comment))))\n  \n\n;;;===========================================================================\n;;;  Initialization\n;;;===========================================================================\n\n;; easymenu.el is for top-level menus only...\n(defunx template-add-submenu (menu &optional where)\n  \"Add the submenu MENU to the end of a menu in WHERE in the menubar.\nWHERE is a list of menus tried to add MENU to.  If no such menu exist,\nno menu is added.  When using Emacs, always add to the \\\"Edit\\\" menu.\nSee `easy-menu-define' for the format of MENU.\"\n  (and menu\n       :EMACS\n       (>= emacs-major-version 21)\n       (boundp 'menu-bar-edit-menu)\n       (let ((keymap (easy-menu-create-menu (car menu) (cdr menu))))\n	 ;; `easy-menu-get-map' doesn't get the right one => use hard-coded\n	 (define-key-after menu-bar-edit-menu (vector (intern (car menu)))\n	   (cons 'menu-item\n		 (cons (car menu)\n		       (if (not (symbolp keymap))\n			   (list keymap)\n			 (cons (symbol-function keymap)\n			       (get keymap 'menu-prop)))))))\n       :XEMACS\n       (featurep 'menubar)\n       (let ((current-menubar default-menubar) path)\n	 (while where\n	   (setq path (list (pop where)))\n	   (if (find-menu-item default-menubar path)\n	       (setq where nil)\n	     (setq path nil)))\n	 (when path (add-submenu path menu)))))\n\n;;;###autoload\n(defunx template-initialize (&rest dummies)\n  ;; checkdoc-params: (dummies)\n  \"Initialized package template.  See variable `template-initialize'.\"\n  (interactive)\n  (setq template-use-package t)\n  (let ((regexp (concat (regexp-quote template-extension) \"\\\\'\")))\n    (or (assoc regexp auto-mode-alist)\n	(push (list regexp nil 'template-new-file) auto-mode-alist)))\n  (when (or (eq template-initialize t)\n	    (memq 'cc-mode template-initialize))\n    (add-hook 'c-mode-common-hook 'template-c-init-fill-function)\n    (add-hook 'antlr-mode-hook 'template-c-init-fill-function))\n  (when (or (eq template-initialize t)\n	    (memq 'de-html-helper template-initialize))\n    (setq html-helper-build-new-buffer nil)\n    (setq html-helper-do-write-file-hooks nil))\n  (when (or (eq template-initialize t)\n	    (memq 'keys template-initialize))\n    (condition-case nil			; older Emacses don't understand all\n	(progn\n	  (define-key ctl-x-map \"t")))
(setq search-ring '("ctl-x" "\"t\"" "TEMPLATE." "mode" "templatess" ".template" "path" "linktext" "bookmarkui" "bookmark" "headerText" "text" "ks-lum " "view" "Find a Course Pro" "response.set"))
(setq shell-command-history nil)
(setq tags-file-name nil)
(setq tags-table-list nil)

;; Buffer section -- buffers listed in same order as in buffer list:
(desktop-create-buffer 206
  nil
  "*info*"
  'Info-mode
  '(anzu-mode global-auto-revert-mode whitespace-cleanup-mode undo-tree-mode whole-line-or-region-mode hes-mode guide-key-mode auto-compile-on-load-mode magit-auto-revert-mode)
  1416347
  '(nil nil)
  t
  '("/usr/share/info/emacs-24/emacs" "Easy Customization" nil)
  '((tab-width . 8) (buffer-file-coding-system . iso-latin-1-unix) (case-fold-search . t)))

(desktop-create-buffer 206
  "/home/akitsuki/.emacs.d/lisp/1.c"
  "1.c"
  'c-mode
  '(abbrev-mode anzu-mode auto-complete-mode global-auto-revert-mode whitespace-cleanup-mode undo-tree-mode whole-line-or-region-mode hes-mode guide-key-mode auto-compile-on-load-mode flycheck-mode goto-address-prog-mode paredit-everywhere-mode bug-reference-prog-mode diff-hl-mode highlight-symbol-mode magit-auto-revert-mode)
  1
  '(nil nil)
  nil
  nil
  nil)

